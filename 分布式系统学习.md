# 框架设计

## 操作系统

- cpu
- 内存  [参考资料](https://blog.csdn.net/junlon2006/article/details/77854898)
  - ptmalloc
  - tcmalloc
  - jemalloc
- 进程
- 线程
- 协程
- Linux系统
  - linux编程
  - linux性能调优
  - linux shell

## 软件体系结构

[软件架构4+1视图模型](https://www.ibm.com/developerworks/cn/rational/r-4p1-view/)

[运用4+1视图模型进行设计](https://www.ibm.com/developerworks/cn/rational/06/r-wenyu/index.html)

## 架构模式

### 代码结构

- 分层结构(layers)
- 管道(pipes&filters)

### 交互系统

- MVC

### 分布式系统

- Actor
- Broker
- Leader-Follower
- MapReduce

### SOA

- 什么是SOA

- SOA和微服务器的区别

  https://dzone.com/articles/microservices-vs-soa-whats-the-differce

### 微服务

- 什么是微服务

- 资料

  书籍：[《微服务设计》](https://martinfowler.com/articles/microservices.html)

  IBM红书：[Microservice Best Practices for Java](https://www.redbooks.ibm.com/redboks/pdfs/sg248357.pdf)

- 容器(Docker)与微服务

## 分布式理论基础

## CAP:

#### 定义：

- Consistency(一致性)：意思是，写操作之后的读操作，必须返回该值

- Availability(可用性)：意思是只要收到用户的请求，服务器就必须给出回应。

- Partition tolerance(分区容错性)：意思是区间通信可能失败。

三者关系：**需要p总是成立，但分区容错性无法避免，所以C和A无法同时满足。**

#### 举例：

![](C:\Users\duoyi\Desktop\pic\1.png)

[参考资料](http://www.ruanyifeng.com/blog/2018/07/cap.html)

如上图，G1 和 G2 是两台跨区的服务器。当出现通讯失败(即分区容错)时：

如果保证 G2 的一致性，那么 G1 必须在写操作时，锁定 G2 的读操作和写操作。只有数据同步后，才能重新开放读写。锁定期间，G2 不能读写，**没有可用性**。

如果保证 G2 的可用性，那么势必不能锁定 G2，所以**一致性不成立**。

综上所述，G2 无法同时做到一致性和可用性。**系统设计时只能选择一个目标。如果追求一致性，那么无法保证所有节点的可用性；如果追求所有节点的可用性，那就没法做到一致性。**

## 一致性

- 强一致型：

- 最终一致性：

## 分布式锁

#### 分布式锁应该满足的条件：

````
1、在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行； 
2、高可用的获取锁与释放锁； 
3、高性能的获取锁与释放锁； 
4、具备可重入特性； 
5、具备锁失效机制，防止死锁； 
6、具备非阻塞锁特性，即没有获取到锁将直接返回获取锁失败。
````

#### 分布式锁的实现方式：[分布式锁实现参考资料](https://blog.csdn.net/wuzhiwei549/article/details/80692278)

- 基于数据库实现。

- 基于缓存(redis等)实现。

- 基于zookeeper实现。

**三种方案的比较**
上面几种方式，哪种方式都无法做到完美。就像CAP一样，在复杂性、可靠性、性能等方面无法同时满足，所以，根据不同的应用场景选择最适合自己的才是王道。

从理解的难易程度角度（从低到高）:
数据库 > 缓存 > Zookeeper

从实现的复杂性角度（从低到高）:
Zookeeper >= 缓存 > 数据库

从性能角度（从高到低）:
缓存 > Zookeeper >= 数据库

从可靠性角度（从高到低）:
Zookeeper > 缓存 > 数据库

## 分布式事务

分布式事务，本质上是对多个数据库的事务进行统一控制,按照控制力度可以分为：不控制、部分控制和完全控制: 

- 不控制就是不引入分布式事务;
- 部分控制就是各种变种的两阶段提交，包括消息事务+最终一致性、TCC模式;
- 完全控制就是完全实现两阶段提交。

部分控制的好处是并发量和性能很好，缺点是数据一致性减弱了，完全控制则是牺牲了性能，保障了一致性，具体用哪种方式，最终还是取决于业务场景

[参考资料](https://blog.csdn.net/wanghang88/article/details/79762761)

# 分布式扩展性设计

## 数据层设计

- 数据分区

- 读写分离

- 主从模式

- 高性能缓存  [参考资料](https://baijiahao.baidu.com/s?id=1619572269435584821&wfr=spider&for=pc)

  - 缓存穿透：指查询一个数据库一定不存在的数据

  - 缓存雪崩：指在某一个时间段，缓存集中过期失效

  - 缓存击穿：指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。

# 分布式可用性设计

- 负载均衡
- 冗余设计
- 服务限流:限流模式主要是提前对各个类型的请求设置最高的QPS阈值，若高于设置的阈值则对该请求直接返回，不再调用后续资源。
- 服务熔断:如果某个目标服务调用慢或者有大量超时，此时，熔断该服务的调用，对于后续调用请求，不在继续调用目标服务，直接返回，快速释放资源。如果目标服务情况好转则恢复调用。
- 服务降级:当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，以此释放服务器资源以保证核心任务的正常运行。

[参考资料](https://blog.csdn.net/llianlianpay/article/details/79768890)

# 分布式事务

## 常用算法

-  PAXOS
- Zab
- Raft
- Gossip
-  两(多)阶段提交

## 幂等性

定义：**实际上就是接口可重复调用，在调用方多次调用的情况下，接口最终得到的结果是一致的。**

实现幂等性的方式：[参考资料](http://www.sohu.com/a/284541897_100028126)

- 全局唯一id
- 悲观锁
- 去重表
- 一次性token
- 多版本并发(MVCC)
- 状态机幂等
- select+insert

#  中间件

### 交互组件

- 消息队列(MQ)
- 远程调用(RPC)

### 数据组件

- 内存数据库
  - redis
  - mongodb
  - memcached

- 分布式数据库引擎

### 日志和大数据

-  ELK
- elasticsearch

## 服务治理

- 命名服务

  - 服务注册
  - 服务自动发现

- 服务管理

  - 服务状态检测
  - 服务启动/停止
  - 服务负载均衡

- 容错处理

  实时屏蔽异常的服务，自动调配请求流量

- 服务监控报警

- 统一配置管理

- 分布式服务跟踪

  诊断服务访问慢，异常抖动等问题

- 过载保护

  灵活定义服务消费者的配额，当其调用量超出最大阈值时，基于不同服务消费者进行QoS区分，触发过载保护。

- 服务访问控制






