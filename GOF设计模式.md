## 创建型

### 抽象工厂

**定义：**抽象工厂模式提供了一个创建一系列相关或者相互依赖对象的接口，无需指定它们具体的类

适用场景：

- 客户端（应用层）不依赖于产品类实例如何被创建、实现等细节
- 强调一系列相关的产品对象（属于同一产品族）一起使用创建对象需要大量的重复代码
- 提供一个产品类的库，所有的产品以同样的接口出现，从而使得客户端不依赖于具体的实现

优点：

- 具体产品在应用层的代码隔离，无需关心创建的细节
- 将一个系列的产品统一到一起创建

缺点：

- 规定了所有可能被创建的产品集合，产品簇中扩展新的产品困难
- 增加了系统的抽象性和理解难度

为了更好理解抽象工厂模式，需要先搞清楚产品等级和产品族的概念，举个粟子：手机有小米手机、华为手机，它们都是手机，这些具体的手机和抽象手机就构成了一个产品等级结构。同样的，路由器有小米路由器，华为路由器，这些具体的路由器和抽象路由器就构成了另外一个产品等级结构，实质上**产品等级结构即产品的继承结构**。小米手机位于手机产品等级结构中，小米路由器位于路由器的产品等级结构中，而小米手机和小米路由器都是小米公司生产的，就构成了一个产品族，同理，华为手机和华为路由器也构成了一个产品族 。划重点就是**产品族中的产品都是由同一个工厂生产的，位于不同的产品等级结构**

````c++
* 抽象产品工厂（定义了同一个产品族的产品生产行为）
 */
public interface IProductFactory {

    /**
     * 生产手机
     * @return
     */
    IPhoneProduct produceTelPhone();

    /**
     * 生产路由器
     * @return
     */
    IRouterProduct produceRouter();
    
    /**
     * 生产笔记本（新增）
     * @return
     */
    IComputerProduct produceComputer();

}
````

**产品族难拓展，产品等级易拓展**。

例如上面的抽象工厂类，新加“生产笔记本”产品时，除了抽象工厂类需要添加，所有的子类，包括小米，华为等都都需要加“笔记本”产品的实现。**所以抽象工厂类只有在产品类型比较稳定，产品等级可以随时变化的情况下使用比较合理。**

### 工厂方法

**定义：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。

**优点：** 

- 1、一个调用者想创建一个对象，只要知道其名称就可以了。 
- 2、扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 
- 3、屏蔽产品的具体实现，调用者只关心产品的接口。

**缺点：**

- 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。

还是以上面的小米，华为为例子：

```
/**
 * 手机产品接口
 */
public interface IPhoneProduct {

    /**
     * 开机
     */
    void start();

    /**
     * 关机
     */
    void shutdown();
    
    /**
     * 拨打电话
     */
    void callUp();
    
    /**
     * 发送短信
     */
    void sendSMS();
}

/**
 * 路由器产品接口
 */
public interface IRouterProduct {

    /**
     * 开机
     */
    void start();

    /**
     * 关机
     */
    void shutdown();

    /**
     * 开启wifi
     */
    void openWifi();

    /**
     * 设置参数
     */
    void setting();
}
```

小米手机和华为手机都继承自手机类，小米路由器和华为路由器都继承自路由器类。**工厂模式适合产品族变化频繁的情况，但如果产品等级太多，需要创建的子类过多会增加系统复杂度。**

### 生成器/创建者模式

**定义：**将一个复杂的对象的**构建**与它的**表示**分离，使得同样的构建过程可以创建不同的表示。隐藏了复杂对象的创建过程，它把复杂对象的创建过程加以抽象，通过子类继承或者重载的方式，动态的创建具有复合属性的对象。

**优点：**

- 使用建造者模式可以使客户端不必知道产品内部组成的细节

- 具体的建造者类之间是相互独立的，这有利于系统的扩展。

- 具体的建造者相互独立，因此可以对建造的过程逐步细化，而不会对其他模块产生任何影响。  

**缺点：**

- 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。

- 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。

#####  建造者模式与抽象工厂模式的比较：

- 与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族 。
- 在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象 。
- 如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车

### 原型模式

**定义：**即“克隆”，原型二字表明了该模式应该有一个样板实例，用户从这个样板对象中复制一个内部属性一致的对象，这个过程也就是我们称的“克隆”。被复制的实例就是我们所称的“原型”，这个原型是可定制的。

**优点：**

- 逃脱构造函数的约束。
- 性能提高

**缺点：**

- 必须实现 Cloneable 接口。
- 配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。

##### 原型模式适用于需要大量实例化且构造函数消耗较大，如一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。使用原型模式减小消耗。

**注意：**原型模式拷贝时有两种方式**浅拷贝**和**深拷贝**。

- **浅拷贝**只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，换句话说，浅复制仅仅是指向   被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。
- **深拷贝**是在新申请一块内存来存储拷贝后对象的数据。

### 单例模式

**定义：**一个类仅有一个实例，并提供一个访问它的全局访问点。

**优点：**

- 在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例。
- 避免对资源的多重占用（比如写文件操作）。

**缺点：**

- 没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。

##### 单例模式构造函数必须是私有成员，且只能有一个实例，同时必须自己创建这个实例，提供给其他对象调用。

## 结构型

### 适配器

### 桥接

### 组合

### 装饰

### 外观

### 享元

### 代理

## 行为模式

### 职责链

### 命令

### 解释器

### 迭代器

### 中介者/调停者

### 备忘录

### 观察者

### 状态

### 策略

### 模板方法

### 访问者

