# Redis笔记

### 1.写时复制(copy-on-write):

多个调用者同时请求相同的资源时，例如主进程A fork()一个子进程B 时,内核并不会立即复制A的整个地址空间，而是让B和A共用一个原来的物理地址，只有在有真正写入改变原地址空间数据时才会给写入的进程复制一个地址空间的副本进行修改。这样做延迟了地址空间复制的时机，如果无写入则根本不需要进行复制地址空间，此时建立子进程B的开销为：**复制父进程的页表以及给子进程创建唯一的进程描述符。**

### 2.慢查询日志：

系统记录的命令的执行时间超过设定阈值的命令信息，包括发生时间，耗时，命令详细信息。

### 3.RDB和AOF:

- RDB:将进程数据生成快照保存到硬盘。
  - 优点：文件紧凑，压缩比高，因此读取RDB恢复速度快；
  - 缺点：每次生成RDB开销大，无法实时持久化，一般用于冷数据备份和复制传输；
- AOF:以独立日志的方式记录每次写命令，重启时再重新执行AOF文件的命令达到恢复数据的目的。工作流程如下：
  - 命令写入(append)：所有命令追加到aof_buf(缓冲区)中；
  - 文件同步(sync):由参数appendfsync控制不同策略向硬盘进行同步操作；
  - 文件重写(rewrite):随着AOF文件越来越大，需要定期或者手动进行重写，达到压缩目的；
  - 重启加载(load):当Redis重启时，加载AOF进行数据恢复。**RDB和AOF同时开启时，优先使用AOF。**

### 4.AOF重写后文件变下的原因：

- 1.进程内已经超时的数据不再写入文件；
- 2.旧的AOF文件含有无效命令，如del key1,hdel key2等。重写使用进程内的数据直接生成，这样的AOF文件只保留最终数据的写入命令；
- 3.多条命令合并成一个，例如：lpush list a,lpush list b可以直接转换成lpush list a b。为防止命令过大造成客户端缓冲区溢出，对于list,set,zset,hash等类型的操作，以64个元素为界拆分多条；

### 5.AOF和RDB重写开销优化：

Redis在需要重写时会fork()一个子进程来负责，主要涉及到CPU，内存和硬盘三部分的消耗：

- CPU:
  - 分析：子进程负责把进程中的数据分批写入文件，这个过程属于CPU密集型操作；
  - 优化：
    - 不做单核绑定；
    - 不和其他CPU密集型服务部署在一起。如果部署多个Redis实例，尽量保证同一时间只有一个实例在重写；
- 内存：
  - 分析：理论上子进程通过fork()操作产生，占用内存和父进程相同，需要两倍内存来完成持久化操作。但使用了**写时复制**技术后子进程和父进程共用一块物理内存，只有父进程在有写请求时才会把要修改的页创建副本进行修改；
  - 优化：
    - 部署多个Redis实例，尽量保证同一时间只有一个实例在重写；
    - 避免在大量写入时进行子进程的重写操作，这样将导致父进程维护大量页的副本，造成内存消耗；
- 硬盘：
  - 分析：子进程主要任务就是将RDB和AOF的文件写入硬盘，势必造成硬盘写入压力；
  - 优化：
    - 不要和其他高硬盘负载业务部署在一起；
    - AOF重写期间消耗大量IO,可以开启配置no-appendfsync-on-rewrite,默认关闭。表示AOF重写期间不做fsync操作；
    - 当开启AOF功能的Redis用于高流量写入场景时，需要使用固态硬盘等；
    - 对于单机配置多个Redis实例，可以配置不同的实例分盘存储AOF文件，分摊硬盘写入压力；

### 6.AOF追加阻塞：

当开启AOF时，常用的同步硬盘的策略时everysec，用于平衡性能和数据安全性。此时，Redis会用另外一条线程每秒执行fsync同步硬盘。当系统资源繁忙时，会造成Redis主线程阻塞，流程分析如下：

- 1.主线程负责写入AOF缓冲区；
- 2.AOF线程负责每秒执行一次同步硬盘操作，并记录最近一次同步时间；
- 3.主线程对比上次AOF同步时间：
  - 如果距上次同步成功时间小于2秒，主线程直接返回继续执行；
  - 反之，主线程会阻塞，直到同步完成；

由上可知，everysec配置最多可以丢失2秒数据，当延迟较高时说明硬盘存在高负载问题，具体优化方案见：**5.AOF和RDB重写开销优化：**

### 7.多Redis实例部署：

当在一台机器上部署多个Redis实例且开启AOF时，彼此之间会产生对CPU和IO的竞争。为防止出现多个子进程同时重写，可以通过程序外部轮询控制AOF重写操作的执行，流程如下：

- 1.外部程序定时轮询所有的Redis实例；
- 2.对于开启了AOF的实例，查看增长率。当增长率超过阈值时，执行bgrewriteaof 命令手动触发当前实例的AOF重写；
- 3.循环检查aof_rewrite_in_progress和aof_current_rewrite_time_sec指标，直达AOF重写完成；
- 4.确认该实例AOF重写完成后再顺序检查其他实例，从而保证机器内每个Redis实例AOF重写串行化执行；

### 8.HyperLogLog：

一种基数算法，可以利用极小的空间完成独立总数的统计，但存在0.81%的失误率。提供了三个命令：

- pfadd:添加
- pfcount:计算独立用户数
- pfmerge:合并

开发者在进行数据结构选型时需要确认：

- 只为了计算独立总数，不需要获取单条数据；
- 可以容忍一定的误差率；

### 9.主从复制：

- 全量复制：同步主节点上全部数据，大量消耗机器和网络资源，应尽量避免；

- 部分复制：根据主节点和从节点的数据偏移量差补发缺少的数据；

通过配置合理的**复制积压缓冲区**尽量避免全量复制。

### 10.读写分离存在的问题：

- 数据延迟：为保证高性能主从复制过程都是异步的，写命令处理完后直接返回给客户端，不等从节点复制完成；
- 过期数据：过期删除策略一般为：**定期和惰性删除:**
  - 定期删除：主节点内部定时任务会循环采样一定数量的键，当发现采样的键过期后执行del命令，之后再同步给从节点。**从节点不主动删除过期键。**
  - 惰性删除：主节点在处理读取命令时检测键是否过期，如果过期则执行del命令并同步给从节点。
- 从节点故障：客户端维护从节点列表，当发现连接的从节点故障时立即切换到其他从节点；

### 11.主节点阻塞：

- 内部原因：
  - 1.不合理的适用API或数据结构。例如适用 hgetall,keys和sort等命令；
  - 2.CPU饱和。例如适用高算法复杂度命令；
  - 3.持久化阻塞。例如fork()命令阻塞和AOF持久化阻塞；
- 外部原因：
  - 1.CPU竞争。例如一台机器上部署多个CPU密集型应用；
  - 2.内存交换：
    - a.保证机器有足够的内存；
    - b.确保所有Redis实例设置最大可用内存，防止极端情况下内存不可控增长；
    - c.降低系统适用swap的优先级；
  - 3.网络问题：
    - a.连接拒绝；
    - b.网络延迟；
    - c.网卡软中断；

### 12.哨兵(Sentinel)的功能：

- 1.监控：定期检测Redis数据节点和其余Sentinel节点是否可达。
- 2.通知：将故障转移的结果通知应用方。
- 3.主节点故障转移：实现从节点晋升主节点，并维持后续正确的主从关系。
- 4.配置提供者：客户端初始化时连接Sentinel来获取主节点信息。

**Sentinel做成集群的作用：**

- 1.对于节点的故障由多个Sentinel共同完成，防止误判。
- 2.单个Sentinel不可用也不会影响功能，提高健壮性。

### 13.三个定时任务：

- 1.**每隔10秒**，每个Sentinel节点向主节点和从节点发送**info**命令获取最新的拓扑结构，作用如下：
  - 1.向主节点执行info命令获取从节点信息，这也是为什么Sentinel节点不需要显式配置监控从节点；
  - 2.当有新的从节点加入时可以及时感知；
  - 3.节点不可达或者故障转移后，可以通过info命令实时更新节点拓扑信息；
- 2.**每隔2秒**，每个Sentinel节点向Redis数据节点的*_sentinel_:hello*频道发送该Sentinel对于主节点的判断以及当前Sentinel节点信息。作用如下：
  - 1.及时发现新的Sentinel节点；
  - 2.Sentinel节点之间交换主节点状态，作为后面客观下线以及领导者选举的依据；
- 3.**每隔1秒**，每个Sentinel会向主节点，从节点和其余的Sentinel节点发送Ping命令做心跳检测，来确认这些节点 是否可达；

### 14.主观下线和客观下线：

- 主观下线：**每隔1秒**，每个Sentinel会向主节点，从节点和其余的Sentinel节点发送Ping命令做心跳检测，当这些节点超过*down-after-milliseconds*没有进行回复时则判断为不可达，进行主观下线。**从节点，Sentinel节点在主观下线后没有后续的故障转移操作。**
- 客观下线：当主观下线的是主节点时，该Sentinel会通过命令：*sentinel is-master-down-by-addr*  向其他Sentinel节点询问对主节点的判断，当超过<quorum>个数则认为主节点确实有问题，进行客观下线。

### 15.Sentinel领导者选举使用 Raft 算法

### 16.故障转移

选出的Sentinel领导者负责进行故障转移，具体步骤：

- 1.从节点中选择一个节点作为主节点；
- 2.Sentinel领导者对选出的从节点执行命令：*slaveof  no  one*,让其成为主节点；
- 3.Sentinel领导者向其他从节点发送命令，让他们成为新主节点的从节点，并开启复制；
- 4.Sentinel领导者将原来的主节点更新为从节点，并保持对其关注，当其恢复后命令其去复制新的主节点；

