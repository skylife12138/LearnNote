# Redis笔记

### 1.写时复制(copy-on-write):

多个调用者同时请求相同的资源时，例如主进程A fork()一个子进程B 时,内核并不会立即复制A的整个地址空间，而是让B和A共用一个原来的物理地址，只有在有真正写入改变原地址空间数据时才会给写入的进程复制一个地址空间的副本进行修改。这样做延迟了地址空间复制的时机，如果无写入则根本不需要进行复制地址空间，此时建立子进程B的开销为：**复制父进程的页表以及给子进程创建唯一的进程描述符。**

### 2.慢查询日志：

系统记录的命令的执行时间超过设定阈值的命令信息，包括发生时间，耗时，命令详细信息。

### 3.RDB和AOF:

- RDB:将进程数据生成快照保存到硬盘。
  - 优点：文件紧凑，压缩比高，因此读取RDB恢复速度快；
  - 缺点：每次生成RDB开销大，无法实时持久化，一般用于冷数据备份和复制传输；
- AOF:以独立日志的方式记录每次写命令，重启时再重新执行AOF文件的命令达到恢复数据的目的。工作流程如下：
  - 命令写入(append)：所有命令追加到aof_buf(缓冲区)中；
  - 文件同步(sync):由参数appendfsync控制不同策略向硬盘进行同步操作；
  - 文件重写(rewrite):随着AOF文件越来越大，需要定期或者手动进行重写，达到压缩目的；
  - 重启加载(load):当Redis重启时，加载AOF进行数据恢复。**RDB和AOF同时开启时，优先使用AOF。**

### 4.AOF重写后文件变下的原因：

- 1.进程内已经超时的数据不再写入文件；
- 2.旧的AOF文件含有无效命令，如del key1,hdel key2等。重写使用进程内的数据直接生成，这样的AOF文件只保留最终数据的写入命令；
- 3.多条命令合并成一个，例如：lpush list a,lpush list b可以直接转换成lpush list a b。为防止命令过大造成客户端缓冲区溢出，对于list,set,zset,hash等类型的操作，以64个元素为界拆分多条；

### 5.AOF和RDB重写开销优化：

Redis在需要重写时会fork()一个子进程来负责，主要涉及到CPU，内存和硬盘三部分的消耗：

- CPU:
  - 分析：子进程负责把进程中的数据分批写入文件，这个过程属于CPU密集型操作；
  - 优化：
    - 不做单核绑定；
    - 不和其他CPU密集型服务部署在一起。如果部署多个Redis实例，尽量保证同一时间只有一个实例在重写；
- 内存：
  - 分析：理论上子进程通过fork()操作产生，占用内存和父进程相同，需要两倍内存来完成持久化操作。但使用了**写时复制**技术后子进程和父进程共用一块物理内存，只有父进程在有写请求时才会把要修改的页创建副本进行修改；
  - 优化：
    - 部署多个Redis实例，尽量保证同一时间只有一个实例在重写；
    - 避免在大量写入时进行子进程的重写操作，这样将导致父进程维护大量页的副本，造成内存消耗；
- 硬盘：
  - 分析：子进程主要任务就是将RDB和AOF的文件写入硬盘，势必造成硬盘写入压力；
  - 优化：
    - 不要和其他高硬盘负载业务部署在一起；
    - AOF重写期间消耗大量IO,可以开启配置no-appendfsync-on-rewrite,默认关闭。表示AOF重写期间不做fsync操作；
    - 当开启AOF功能的Redis用于高流量写入场景时，需要使用固态硬盘等；
    - 对于单机配置多个Redis实例，可以配置不同的实例分盘存储AOF文件，分摊硬盘写入压力；

### 6.AOF追加阻塞：

当开启AOF时，常用的同步硬盘的策略时everysec，用于平衡性能和数据安全性。此时，Redis会用另外一条线程每秒执行fsync同步硬盘。当系统资源繁忙时，会造成Redis主线程阻塞，流程分析如下：

- 1.主线程负责写入AOF缓冲区；
- 2.AOF线程负责每秒执行一次同步硬盘操作，并记录最近一次同步时间；
- 3.主线程对比上次AOF同步时间：
  - 如果距上次同步成功时间小于2秒，主线程直接返回继续执行；
  - 反之，主线程会阻塞，直到同步完成；

由上可知，everysec配置最多可以丢失2秒数据，当延迟较高时说明硬盘存在高负载问题，具体优化方案见：**5.AOF和RDB重写开销优化：**

### 7.多Redis实例部署：

当在一台机器上部署多个Redis实例且开启AOF时，彼此之间会产生对CPU和IO的竞争。为防止出现多个子进程同时重写，可以通过程序外部轮询控制AOF重写操作的执行，流程如下：

- 1.外部程序定时轮询所有的Redis实例；
- 2.对于开启了AOF的实例，查看增长率。当增长率超过阈值时，执行bgrewriteaof 命令手动触发当前实例的AOF重写；
- 3.循环检查aof_rewrite_in_progress和aof_current_rewrite_time_sec指标，直达AOF重写完成；
- 4.确认该实例AOF重写完成后再顺序检查其他实例，从而保证机器内每个Redis实例AOF重写串行化执行；

### 8.HyperLogLog：

一种基数算法，可以利用极小的空间完成独立总数的统计，但存在0.81%的失误率。提供了三个命令：

- pfadd:添加
- pfcount:计算独立用户数
- pfmerge:合并

开发者在进行数据结构选型时需要确认：

- 只为了计算独立总数，不需要获取单条数据；
- 可以容忍一定的误差率；

### 9.主从复制：

- 全量复制：同步主节点上全部数据，大量消耗机器和网络资源，应尽量避免；

- 部分复制：根据主节点和从节点的数据偏移量差补发缺少的数据；

通过配置合理的**复制积压缓冲区**尽量避免全量复制。

### 10.读写分离存在的问题：

- 数据延迟：为保证高性能主从复制过程都是异步的，写命令处理完后直接返回给客户端，不等从节点复制完成；
- 过期数据：过期删除策略一般为：**定期和惰性删除:**
  - 定期删除：主节点内部定时任务会循环采样一定数量的键，当发现采样的键过期后执行del命令，之后再同步给从节点。**从节点不主动删除过期键。**
  - 惰性删除：主节点在处理读取命令时检测键是否过期，如果过期则执行del命令并同步给从节点。
- 从节点故障：客户端维护从节点列表，当发现连接的从节点故障时立即切换到其他从节点；

### 11.主节点阻塞：

- 内部原因：
  - 1.不合理的适用API或数据结构。例如适用 hgetall,keys和sort等命令；
  - 2.CPU饱和。例如适用高算法复杂度命令；
  - 3.持久化阻塞。例如fork()命令阻塞和AOF持久化阻塞；
- 外部原因：
  - 1.CPU竞争。例如一台机器上部署多个CPU密集型应用；
  - 2.内存交换：
    - a.保证机器有足够的内存；
    - b.确保所有Redis实例设置最大可用内存，防止极端情况下内存不可控增长；
    - c.降低系统适用swap的优先级；
  - 3.网络问题：
    - a.连接拒绝；
    - b.网络延迟；
    - c.网卡软中断；