## 模块化

### 参考书籍：

- 《UNIX编程艺术》
- 《UML和模块应用》
  - GRASP相关
- 《软件建模与设计》
  - 第8章 对象和类组织

### 原则

- 基于职责设计

### 组织分类

- 实体
- 边界
- 控制

### 封装

- 好的封装

  - 不过多披露自身细节
  - 不直接调用其他模块代码
  - 不胡乱共享全局数据

- 接口

  - 基本概念

    - 提供服务器的代码和使用服务的代码间的一条清晰的分界线
    - 定义了那些功能或者数据元素可以为程序的其他部分使用

  - 设计原则

    - 隐藏细节

      - 方便对接口进行扩充，优化，替换实现

    - 避免全局变量

      - 需要引用的数据都通过函数参数传递给函数
    
      - 用户可以改变变量，维护值的一致性就太困难
    
    - 尽可能少
    
      - 提供外界需要的全部功能，但是绝不要多
      - 多了难写，难维护，难学习，难使用
    
    - 正交
    
      - 函数在功能方面不应该有过度的重叠
      - 为同一件事提供多种方式，这种冗余其实是应该反对的。
    
    - 杜绝小动作
    
      - 不要写秘密文件
      - 不要修改某个秘密变量
      - 不要改变某些全局性数据
      - 不要轻易改变调用者数据
      - 不要对外部太多依赖，尽量自给自足
  
- 最佳模块大小

  - 缺陷与模块大小的Hatton U型图
  - 模块小时，计划所有复杂度都在于接口

### 紧凑型与正交性

- 紧凑性
  - 一个设计能否装进人脑中
- 正交性
  - 每个动作只改变一件事，不会影响其他
- SPOT原则
  - 避免重复
- 强单一中心

### 层次结构

- 方向
  - 自顶而下
    - 从抽象到具体
  - 自底而上
    - 从具体到抽象
  - 实际代码往往是两者的综合产物
    - “胶合层”出现
- UNIX
  - 薄胶合层/浅封层
- OO
  - 厚胶合层和复杂层次

### 程序库

- 把程序分解成由胶合层连接的库集合
- 共享库
- 插件

### 模块式代码

- 全局变量对模块时毒药
- 单个模块大小是否适中(Hatton U型)
- 模块内单个函数的复杂性是否适中
- API意义清楚，容易理解
- API数量不多
- 模块复杂性和入口点数量的平方成正比

## 重构

### 参考书籍

- 重构 改善既有代码的设计

### 重构的原则

- 不改变软件的可观察行为
- 提高其可理解性
- 降低其修改成本

### 代码的坏味道

- 重复的代码
- 过长的函数
- 过大的类
- 过长的参数
- 发散式变化
- 散弹式修改
- 依恋情结
- 数据泥团
- 基本类型偏执
- switch statement
- 平行继承体系
- 冗赘类
- 令人迷惑的暂时字段
- 过度耦合的消息链
- 中间人
- 过多的注释

## 防御式编程

## 测试驱动开发

## 技术债务

## MVP(minimum viable product)

